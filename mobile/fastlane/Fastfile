# Fastfile for AfrikaBurn Companion
# Compose Multiplatform app deployment automation
#
# Documentation: https://docs.fastlane.tools

default_platform(:android)

# App Store Connect API Key for CI authentication (avoids password/2FA issues)
# Requires secrets: ASC_KEY_ID, ASC_ISSUER_ID, ASC_KEY_CONTENT (base64 .p8)
def asc_api_key
  if ENV['ASC_KEY_ID'] && ENV['ASC_ISSUER_ID'] && ENV['ASC_KEY_CONTENT']
    app_store_connect_api_key(
      key_id: ENV['ASC_KEY_ID'],
      issuer_id: ENV['ASC_ISSUER_ID'],
      key_content: ENV['ASC_KEY_CONTENT'],
      is_key_content_base64: true
    )
  else
    nil
  end
end

# Resolve project paths relative to this Fastfile to avoid cwd issues in CI.
def mobile_root
  File.expand_path("..", __dir__)
end

def compose_app_root
  File.join(mobile_root, "composeApp")
end

# ============================================================================
# ANDROID LANES
# ============================================================================
platform :android do

  desc "Run Android unit tests"
  lane :test do
    gradle(
      project_dir: mobile_root,
      task: ":composeApp:testDebugUnitTest"
    )
  end

  desc "Run detekt code analysis"
  lane :lint do
    gradle(
      project_dir: mobile_root,
      task: "detekt"
    )
  end

  desc "Build debug APK"
  lane :build_debug do
    gradle(
      project_dir: mobile_root,
      task: ":composeApp:assembleDebug"
    )

    apk_location = lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH]
    UI.success("Debug APK built: #{apk_location}")
  end

  desc "Build release AAB for Play Store"
  lane :build_release do
    ensure_env_vars(
      env_vars: ["KEYSTORE_PATH", "KEYSTORE_PASSWORD", "KEY_ALIAS", "KEY_PASSWORD"]
    )

    gradle(
      project_dir: mobile_root,
      task: ":composeApp:bundleRelease",
      properties: {
        "android.injected.signing.store.file" => ENV["KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      }
    )

    aab_location = File.join(compose_app_root, "build/outputs/bundle/release/composeApp-release.aab")
    UI.success("Release AAB built: #{aab_location}")
  end

  desc "Build release APK (for direct distribution)"
  lane :build_release_apk do
    ensure_env_vars(
      env_vars: ["KEYSTORE_PATH", "KEYSTORE_PASSWORD", "KEY_ALIAS", "KEY_PASSWORD"]
    )

    gradle(
      project_dir: mobile_root,
      task: ":composeApp:assembleRelease",
      properties: {
        "android.injected.signing.store.file" => ENV["KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      }
    )
  end

  desc "Increment version code"
  lane :bump_version do
    build_file = File.join(compose_app_root, "build.gradle.kts")
    content = File.read(build_file)

    current_version_code = content.match(/versionCode = (\d+)/)[1].to_i
    new_version_code = current_version_code + 1

    new_content = content.gsub(/versionCode = \d+/, "versionCode = #{new_version_code}")
    File.write(build_file, new_content)

    UI.success("Version code bumped: #{current_version_code} -> #{new_version_code}")
    new_version_code
  end

  desc "Deploy to Play Store Internal Testing track"
  lane :internal do
    test
    lint
    bump_version
    build_release

    upload_to_play_store(
      track: "internal",
      aab: File.join(compose_app_root, "build/outputs/bundle/release/composeApp-release.aab"),
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      release_status: "completed"
    )

    UI.success("Successfully deployed to Internal Testing!")
  end

  desc "Upload Play Store internal track build (CI)"
  lane :upload_internal do |options|
    ensure_env_vars(
      env_vars: ["PLAY_STORE_JSON_KEY"]
    )

    aab_path = options[:aab] || File.join(compose_app_root, "build/outputs/bundle/release/composeApp-release.aab")

    resolved_aab = Dir.glob(aab_path).first || File.expand_path(aab_path, Dir.pwd)
    unless File.exist?(resolved_aab)
      UI.user_error!("Missing AAB at #{aab_path}. Provide via aab: option.")
    end

    resolved_aab = File.expand_path(resolved_aab, Dir.pwd)

    upload_to_play_store(
      track: "internal",
      aab: resolved_aab,
      json_key: ENV["PLAY_STORE_JSON_KEY"],
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      release_status: "completed"
    )

    UI.success("Successfully deployed to Internal Testing!")
  end

  desc "Upload Play Store screenshots from local screenshots directory"
  lane :upload_screenshots do
    ensure_env_vars(
      env_vars: ["PLAY_STORE_JSON_KEY"]
    )

    screenshots_dir = File.join(mobile_root, "fastlane", "screenshots", "android")
    unless Dir.exist?(screenshots_dir)
      UI.user_error!("Missing Android screenshots at #{screenshots_dir}. See SCREENSHOTS.md for instructions.")
    end

    png_files = Dir.glob(File.join(screenshots_dir, "**", "*.png"))
    if png_files.empty?
      UI.important("No Android screenshot PNGs found. Skipping upload.")
      next
    end

    UI.message("Uploading #{png_files.length} Android screenshots...")
    upload_to_play_store(
      json_key: ENV["PLAY_STORE_JSON_KEY"],
      skip_upload_aab: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: false
    )

    UI.success("Successfully uploaded Play Store screenshots!")
  end

  desc "Deploy to Play Store Beta (Open Testing)"
  lane :beta do
    test
    lint
    bump_version
    build_release

    upload_to_play_store(
      track: "beta",
      aab: File.join(compose_app_root, "build/outputs/bundle/release/composeApp-release.aab"),
      skip_upload_metadata: false,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Successfully deployed to Beta!")
  end

  desc "Deploy to Play Store Production (with staged rollout)"
  lane :release do |options|
    rollout_percentage = options[:rollout] || 0.1

    test
    lint
    bump_version
    build_release

    upload_to_play_store(
      track: "production",
      aab: File.join(compose_app_root, "build/outputs/bundle/release/composeApp-release.aab"),
      rollout: rollout_percentage.to_s
    )

    UI.success("Successfully deployed to Production with #{(rollout_percentage * 100).to_i}% rollout!")
  end

  desc "Promote Internal to Beta"
  lane :promote_to_beta do
    upload_to_play_store(
      track: "internal",
      track_promote_to: "beta",
      skip_upload_aab: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Promoted Internal to Beta!")
  end

  desc "Promote Beta to Production"
  lane :promote_to_production do |options|
    rollout_percentage = options[:rollout] || 0.1

    upload_to_play_store(
      track: "beta",
      track_promote_to: "production",
      rollout: rollout_percentage.to_s,
      skip_upload_aab: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Promoted Beta to Production with #{(rollout_percentage * 100).to_i}% rollout!")
  end

end

# ============================================================================
# iOS LANES
# ============================================================================
platform :ios do

  desc "Sync code signing certificates and provisioning profiles"
  lane :certificates do
    # Create a temporary keychain on CI so codesign doesn't hang
    # waiting for a keychain password prompt during framework embedding
    setup_ci if is_ci

    match(
      type: "appstore",
      readonly: is_ci,
      app_identifier: "io.asterixorobelix.afrikaburn.Afrikaburn"
    )
  end

  desc "Sync development certificates"
  lane :certificates_dev do
    setup_ci if is_ci

    match(
      type: "development",
      readonly: is_ci,
      app_identifier: "io.asterixorobelix.afrikaburn.Afrikaburn"
    )
  end

  desc "Run precheck to catch common App Store rejection issues"
  lane :precheck_app do
    precheck(
      app_identifier: "io.asterixorobelix.afrikaburn.Afrikaburn",
      unreachable_urls: :error,
      other_platforms: :error
    )
  end

  desc "Run tests on iPhone and iPad simulators to catch launch crashes"
  lane :test do
    ios_ws = File.join(mobile_root, "iosApp", "iosApp.xcworkspace")
    ios_proj = File.join(mobile_root, "iosApp", "iosApp.xcodeproj")
    container = File.directory?(ios_ws) ? { workspace: ios_ws } : { project: ios_proj }

    run_tests(
      **container,
      scheme: "iosApp",
      devices: [
        "iPhone 16 Pro Max",
        "iPad Pro 11-inch (M4)"
      ],
      result_bundle: true
    )
  end

  desc "Build Kotlin Multiplatform framework (all targets)"
  lane :build_framework do
    gradle(
      project_dir: mobile_root,
      task: ":composeApp:assembleReleaseXCFramework"
    )

    UI.success("XCFramework built successfully!")
  end

  desc "Build Kotlin framework for device only (arm64, faster for CD)"
  lane :build_framework_device do
    gradle(
      project_dir: mobile_root,
      task: ":composeApp:assembleReleaseFrameworkDevice"
    )

    UI.success("Device framework built successfully!")
  end

  desc "Build iOS app for App Store"
  lane :build do
    # On CI, framework is pre-built by the workflow's Gradle step
    unless is_ci
      build_framework
    end

    # Sync certificates
    certificates

    ios_ws = File.join(mobile_root, "iosApp", "iosApp.xcworkspace")
    ios_proj = File.join(mobile_root, "iosApp", "iosApp.xcodeproj")
    container = File.directory?(ios_ws) ? { workspace: ios_ws } : { project: ios_proj }

    build_app(
      **container,
      scheme: "iosApp",
      export_method: "app-store",
      output_directory: "./build",
      output_name: "AfrikaBurnCompanion.ipa",
      clean: true,
      xcargs: "CODE_SIGN_STYLE=Manual DEVELOPMENT_TEAM=#{ENV['APPLE_TEAM_ID']} CODE_SIGN_IDENTITY='Apple Distribution' PROVISIONING_PROFILE_SPECIFIER='match AppStore io.asterixorobelix.afrikaburn.Afrikaburn'"
    )

    UI.success("iOS app built successfully!")
  end

  desc "Build iOS app for development/testing"
  lane :build_dev do
    build_framework
    certificates_dev

    ios_ws = File.join(mobile_root, "iosApp", "iosApp.xcworkspace")
    ios_proj = File.join(mobile_root, "iosApp", "iosApp.xcodeproj")
    container = File.directory?(ios_ws) ? { workspace: ios_ws } : { project: ios_proj }

    build_app(
      **container,
      scheme: "iosApp",
      export_method: "development",
      output_directory: "./build",
      output_name: "AfrikaBurnCompanion-dev.ipa"
    )
  end

  desc "Deploy to TestFlight"
  lane :beta do
    build

    api_key = asc_api_key
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      notify_external_testers: false,
      changelog: generate_changelog
    )

    UI.success("Successfully deployed to TestFlight!")
  end

  desc "Upload App Store screenshots from local screenshots directory"
  lane :upload_screenshots do
    screenshots_dir = File.join(mobile_root, "fastlane", "screenshots", "ios")
    unless Dir.exist?(screenshots_dir)
      UI.user_error!("Missing iOS screenshots at #{screenshots_dir}. See SCREENSHOTS.md for instructions.")
    end

    png_files = Dir.glob(File.join(screenshots_dir, "**", "*.png"))
    if png_files.empty?
      UI.important("No iOS screenshot PNGs found. Skipping upload.")
      next
    end

    UI.message("Uploading #{png_files.length} iOS screenshots...")
    api_key = asc_api_key
    deliver(
      api_key: api_key,
      skip_binary_upload: true,
      skip_metadata: true,
      skip_screenshots: false,
      overwrite_screenshots: true,
      screenshots_path: screenshots_dir,
      run_precheck_before_submit: false
    )

    UI.success("Successfully uploaded App Store screenshots!")
  end

  desc "Deploy to TestFlight with external testers"
  lane :beta_external do
    build

    api_key = asc_api_key
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: false,
      distribute_external: true,
      notify_external_testers: true,
      groups: ["Beta Testers"],
      changelog: generate_changelog
    )

    UI.success("Successfully deployed to TestFlight for external testers!")
  end

  desc "Submit to App Store for review"
  lane :release do
    build

    api_key = asc_api_key
    upload_to_app_store(
      api_key: api_key,
      submit_for_review: false,
      automatic_release: false,
      force: true,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false
      }
    )

    UI.success("Successfully uploaded to App Store Connect!")
    UI.important("Remember to submit for review manually in App Store Connect")
  end

  desc "Submit to App Store and request review"
  lane :release_submit do
    precheck_app
    build

    api_key = asc_api_key
    upload_to_app_store(
      api_key: api_key,
      submit_for_review: true,
      automatic_release: true,
      force: true,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false
      }
    )

    UI.success("Successfully submitted to App Store for review!")
  end

end

# ============================================================================
# SHARED / UTILITY LANES
# ============================================================================

desc "Generate changelog from recent git commits"
private_lane :generate_changelog do
  changelog = changelog_from_git_commits(
    commits_count: 10,
    pretty: "- %s",
    date_format: "short",
    merge_commit_filtering: "exclude_merges"
  )

  # Limit length for App Store
  if changelog.length > 4000
    changelog = changelog[0..3990] + "..."
  end

  changelog
end

desc "Print changelog (useful for release notes)"
lane :changelog do
  puts generate_changelog
end

desc "Run all tests (Android)"
lane :test_all do
  android_test
end

desc "Clean build artifacts"
lane :clean do
  gradle(
    project_dir: "..",
    task: "clean"
  )

  # Clean fastlane build directory
  sh("rm -rf ./build")

  UI.success("Build artifacts cleaned!")
end

desc "Check if all environment variables are configured"
lane :check_env do
  required_vars = [
    "KEYSTORE_PATH",
    "KEYSTORE_PASSWORD",
    "KEY_ALIAS",
    "KEY_PASSWORD"
  ]

  ios_vars = [
    "MATCH_PASSWORD",
    "MATCH_GIT_URL"
  ]

  UI.header("Android Environment Check")
  required_vars.each do |var|
    if ENV[var].nil? || ENV[var].empty?
      UI.error("Missing: #{var}")
    else
      UI.success("Found: #{var}")
    end
  end

  UI.header("iOS Environment Check")
  ios_vars.each do |var|
    if ENV[var].nil? || ENV[var].empty?
      UI.error("Missing: #{var}")
    else
      UI.success("Found: #{var}")
    end
  end
end

# Error handling
error do |lane, exception|
  UI.error("Lane #{lane} failed with error: #{exception.message}")
end
