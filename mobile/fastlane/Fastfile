# Fastfile for AfrikaBurn Companion
# Compose Multiplatform app deployment automation
#
# Documentation: https://docs.fastlane.tools

default_platform(:android)

# App Store Connect API Key for CI authentication (avoids password/2FA issues)
# Requires secrets: ASC_KEY_ID, ASC_ISSUER_ID, ASC_KEY_CONTENT (base64 .p8)
def asc_api_key
  if ENV['ASC_KEY_ID'] && ENV['ASC_ISSUER_ID'] && ENV['ASC_KEY_CONTENT']
    app_store_connect_api_key(
      key_id: ENV['ASC_KEY_ID'],
      issuer_id: ENV['ASC_ISSUER_ID'],
      key_content: ENV['ASC_KEY_CONTENT'],
      is_key_content_base64: true
    )
  else
    nil
  end
end

# Resolve project paths relative to this Fastfile to avoid cwd issues in CI.
def mobile_root
  File.expand_path("..", __dir__)
end

def compose_app_root
  File.join(mobile_root, "composeApp")
end

def android_connected_devices
  output = sh("adb devices")
  output.lines.filter_map do |line|
    parts = line.strip.split
    next if parts.empty? || parts[0] == "List" || parts[1] != "device"
    parts[0]
  end
end

def android_emulator_tools
  sdk_root = ENV["ANDROID_SDK_ROOT"] || ENV["ANDROID_HOME"]
  return nil if sdk_root.nil? || sdk_root.empty?

  sdkmanager = [
    File.join(sdk_root, "cmdline-tools", "latest", "bin", "sdkmanager"),
    File.join(sdk_root, "tools", "bin", "sdkmanager")
  ].find { |path| File.exist?(path) }

  avdmanager = [
    File.join(sdk_root, "cmdline-tools", "latest", "bin", "avdmanager"),
    File.join(sdk_root, "tools", "bin", "avdmanager")
  ].find { |path| File.exist?(path) }

  emulator = File.join(sdk_root, "emulator", "emulator")

  return nil unless sdkmanager && avdmanager && File.exist?(emulator)

  {
    sdkmanager: sdkmanager,
    avdmanager: avdmanager,
    emulator: emulator
  }
end

def wait_for_emulator_boot(serial, timeout_seconds: 360)
  start = Time.now
  loop do
    boot = sh("adb -s #{serial} shell getprop sys.boot_completed 2>/dev/null || true").strip
    anim = sh("adb -s #{serial} shell getprop init.svc.bootanim 2>/dev/null || true").strip
    break if boot == "1" && anim == "stopped"

    if Time.now - start > timeout_seconds
      UI.user_error!("Emulator #{serial} did not finish booting within #{timeout_seconds}s")
    end

    sleep(5)
  end

  sh("adb -s #{serial} shell settings put global window_animation_scale 0")
  sh("adb -s #{serial} shell settings put global transition_animation_scale 0")
  sh("adb -s #{serial} shell settings put global animator_duration_scale 0")
end

def ensure_android_screenshot_device!
  devices = android_connected_devices
  return devices.first unless devices.empty?

  auto_boot = ENV.fetch("FASTLANE_AUTO_BOOT_ANDROID_EMULATOR", ENV["CI"] == "true" ? "true" : "false")
  unless auto_boot == "true"
    UI.user_error!("No Android device/emulator connected. Start one manually, or set FASTLANE_AUTO_BOOT_ANDROID_EMULATOR=true.")
  end

  tools = android_emulator_tools
  unless tools
    UI.user_error!("Android emulator tools not found. Set ANDROID_SDK_ROOT/ANDROID_HOME with emulator, sdkmanager, and avdmanager installed.")
  end

  avd_name = ENV.fetch("ANDROID_AVD_NAME", "fastlane-ci-api34")
  api_level = ENV.fetch("ANDROID_EMULATOR_API_LEVEL", "34")
  abi = ENV.fetch("ANDROID_EMULATOR_ABI", "x86_64")
  image = "system-images;android-#{api_level};google_apis;#{abi}"

  available_avds = sh("#{tools[:emulator]} -list-avds || true").lines.map(&:strip)
  unless available_avds.include?(avd_name)
    sh("yes | #{tools[:sdkmanager]} --install '#{image}'")
    sh("echo 'no' | #{tools[:avdmanager]} create avd -n '#{avd_name}' -k '#{image}' --device 'pixel_6' --force")
  end

  sh("nohup #{tools[:emulator]} -avd '#{avd_name}' -no-window -no-audio -no-boot-anim -gpu swiftshader_indirect -no-snapshot >/tmp/#{avd_name}.log 2>&1 &")
  sh("adb wait-for-device")

  serial = ""
  30.times do
    serial = android_connected_devices.first.to_s
    break unless serial.empty?
    sleep(2)
  end

  UI.user_error!("Emulator started but no adb device became available.") if serial.empty?

  wait_for_emulator_boot(serial, timeout_seconds: ENV.fetch("ANDROID_EMULATOR_BOOT_TIMEOUT", "420").to_i)
  serial
end

# ============================================================================
# ANDROID LANES
# ============================================================================
platform :android do

  desc "Run Android unit tests"
  lane :test do
    gradle(
      project_dir: mobile_root,
      task: ":composeApp:testDebugUnitTest"
    )
  end

  desc "Run detekt code analysis"
  lane :lint do
    gradle(
      project_dir: mobile_root,
      task: "detekt"
    )
  end

  desc "Build debug APK"
  lane :build_debug do
    gradle(
      project_dir: mobile_root,
      task: ":composeApp:assembleDebug"
    )

    apk_location = lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH]
    UI.success("Debug APK built: #{apk_location}")
  end

  desc "Build release AAB for Play Store"
  lane :build_release do
    ensure_env_vars(
      env_vars: ["KEYSTORE_PATH", "KEYSTORE_PASSWORD", "KEY_ALIAS", "KEY_PASSWORD"]
    )

    gradle(
      project_dir: mobile_root,
      task: ":composeApp:bundleRelease",
      properties: {
        "android.injected.signing.store.file" => ENV["KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      }
    )

    aab_location = File.join(compose_app_root, "build/outputs/bundle/release/composeApp-release.aab")
    UI.success("Release AAB built: #{aab_location}")
  end

  desc "Build release APK (for direct distribution)"
  lane :build_release_apk do
    ensure_env_vars(
      env_vars: ["KEYSTORE_PATH", "KEYSTORE_PASSWORD", "KEY_ALIAS", "KEY_PASSWORD"]
    )

    gradle(
      project_dir: mobile_root,
      task: ":composeApp:assembleRelease",
      properties: {
        "android.injected.signing.store.file" => ENV["KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      }
    )
  end

  desc "Increment version code"
  lane :bump_version do
    build_file = File.join(compose_app_root, "build.gradle.kts")
    content = File.read(build_file)

    current_version_code = content.match(/versionCode = (\d+)/)[1].to_i
    new_version_code = current_version_code + 1

    new_content = content.gsub(/versionCode = \d+/, "versionCode = #{new_version_code}")
    File.write(build_file, new_content)

    UI.success("Version code bumped: #{current_version_code} -> #{new_version_code}")
    new_version_code
  end

  desc "Deploy to Play Store Internal Testing track"
  lane :internal do
    test
    lint
    bump_version
    build_release

    upload_to_play_store(
      track: "internal",
      aab: File.join(compose_app_root, "build/outputs/bundle/release/composeApp-release.aab"),
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      release_status: "completed"
    )

    UI.success("Successfully deployed to Internal Testing!")
  end

  desc "Capture Android screenshots for Play Store"
  lane :screenshots do
    ensure_android_screenshot_device!

    gradle(
      project_dir: mobile_root,
      task: ":composeApp:assembleDebug"
    )

    gradle(
      project_dir: mobile_root,
      task: ":composeApp:assembleDebugAndroidTest"
    )

    capture_android_screenshots
    UI.success("Android screenshots captured to fastlane/screenshots/android")
  end

  desc "Upload Play Store internal track build (CI)"
  lane :upload_internal do |options|
    ensure_env_vars(
      env_vars: ["PLAY_STORE_JSON_KEY"]
    )

    aab_path = options[:aab] || File.join(compose_app_root, "build/outputs/bundle/release/composeApp-release.aab")

    resolved_aab = Dir.glob(aab_path).first || File.expand_path(aab_path, Dir.pwd)
    unless File.exist?(resolved_aab)
      UI.user_error!("Missing AAB at #{aab_path}. Provide via aab: option.")
    end

    resolved_aab = File.expand_path(resolved_aab, Dir.pwd)

    upload_to_play_store(
      track: "internal",
      aab: resolved_aab,
      json_key: ENV["PLAY_STORE_JSON_KEY"],
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      release_status: "completed"
    )

    UI.success("Successfully deployed to Internal Testing!")
  end

  desc "Upload Play Store screenshots from artifacts directory"
  lane :upload_screenshots do
    ensure_env_vars(
      env_vars: ["PLAY_STORE_JSON_KEY"]
    )

    screenshots_dir = "screenshots/android"
    unless Dir.exist?(screenshots_dir)
      UI.user_error!("Missing Android screenshots directory at #{screenshots_dir}.")
    end

    if Dir.glob("#{screenshots_dir}/**/*.png").empty?
      UI.important("No Android screenshots found. Skipping upload.")
      next
    end

    upload_to_play_store(
      json_key: ENV["PLAY_STORE_JSON_KEY"],
      skip_upload_aab: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: false,
      release_status: "completed"
    )

    UI.success("Successfully uploaded Play Store screenshots!")
  end

  desc "CI lane: build, capture screenshots, and deploy to Internal Testing"
  lane :ci_internal do |options|
    build_release
    screenshots
    upload_internal(options)
  end

  desc "Deploy to Play Store Beta (Open Testing)"
  lane :beta do
    test
    lint
    bump_version
    build_release

    upload_to_play_store(
      track: "beta",
      aab: File.join(compose_app_root, "build/outputs/bundle/release/composeApp-release.aab"),
      skip_upload_metadata: false,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Successfully deployed to Beta!")
  end

  desc "Deploy to Play Store Production (with staged rollout)"
  lane :release do |options|
    rollout_percentage = options[:rollout] || 0.1

    test
    lint
    bump_version
    build_release

    upload_to_play_store(
      track: "production",
      aab: File.join(compose_app_root, "build/outputs/bundle/release/composeApp-release.aab"),
      rollout: rollout_percentage.to_s
    )

    UI.success("Successfully deployed to Production with #{(rollout_percentage * 100).to_i}% rollout!")
  end

  desc "Promote Internal to Beta"
  lane :promote_to_beta do
    upload_to_play_store(
      track: "internal",
      track_promote_to: "beta",
      skip_upload_aab: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Promoted Internal to Beta!")
  end

  desc "Promote Beta to Production"
  lane :promote_to_production do |options|
    rollout_percentage = options[:rollout] || 0.1

    upload_to_play_store(
      track: "beta",
      track_promote_to: "production",
      rollout: rollout_percentage.to_s,
      skip_upload_aab: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Promoted Beta to Production with #{(rollout_percentage * 100).to_i}% rollout!")
  end

end

# ============================================================================
# iOS LANES
# ============================================================================
platform :ios do

  desc "Sync code signing certificates and provisioning profiles"
  lane :certificates do
    # Create a temporary keychain on CI so codesign doesn't hang
    # waiting for a keychain password prompt during framework embedding
    setup_ci if is_ci

    match(
      type: "appstore",
      readonly: is_ci,
      app_identifier: "io.asterixorobelix.afrikaburn.Afrikaburn"
    )
  end

  desc "Sync development certificates"
  lane :certificates_dev do
    setup_ci if is_ci

    match(
      type: "development",
      readonly: is_ci,
      app_identifier: "io.asterixorobelix.afrikaburn.Afrikaburn"
    )
  end

  desc "Run precheck to catch common App Store rejection issues"
  lane :precheck_app do
    precheck(
      app_identifier: "io.asterixorobelix.afrikaburn.Afrikaburn",
      unreachable_urls: :error,
      other_platforms: :error
    )
  end

  desc "Capture screenshots on iPhone and iPad simulators"
  lane :screenshots do
    helper_path = File.join(mobile_root, "iosApp/AfrikaburnUITests/SnapshotHelper.swift")

    unless File.exist?(helper_path)
      UI.important("Snapshot helper missing at #{helper_path}. Skipping iOS screenshots.")
      next
    end

    sh("xcrun simctl shutdown all || true")
    sh("killall Simulator 2>/dev/null || true")

    capture_screenshots(check_helper_is_current: false)
    frame_screenshots
  end

  desc "Run tests on iPhone and iPad simulators to catch launch crashes"
  lane :test do
    ios_ws = File.join(mobile_root, "iosApp", "iosApp.xcworkspace")
    ios_proj = File.join(mobile_root, "iosApp", "iosApp.xcodeproj")
    container = File.directory?(ios_ws) ? { workspace: ios_ws } : { project: ios_proj }

    run_tests(
      **container,
      scheme: "iosApp",
      devices: [
        "iPhone 16 Pro Max",
        "iPad Pro 11-inch (M4)"
      ],
      result_bundle: true
    )
  end

  desc "Build Kotlin Multiplatform framework (all targets)"
  lane :build_framework do
    gradle(
      project_dir: mobile_root,
      task: ":composeApp:assembleReleaseXCFramework"
    )

    UI.success("XCFramework built successfully!")
  end

  desc "Build Kotlin framework for device only (arm64, faster for CD)"
  lane :build_framework_device do
    gradle(
      project_dir: mobile_root,
      task: ":composeApp:assembleReleaseFrameworkDevice"
    )

    UI.success("Device framework built successfully!")
  end

  desc "Build iOS app for App Store"
  lane :build do
    # On CI, framework is pre-built by the workflow's Gradle step
    unless is_ci
      build_framework
    end

    # Sync certificates
    certificates

    ios_ws = File.join(mobile_root, "iosApp", "iosApp.xcworkspace")
    ios_proj = File.join(mobile_root, "iosApp", "iosApp.xcodeproj")
    container = File.directory?(ios_ws) ? { workspace: ios_ws } : { project: ios_proj }

    build_app(
      **container,
      scheme: "iosApp",
      export_method: "app-store",
      output_directory: "./build",
      output_name: "AfrikaBurnCompanion.ipa",
      clean: true,
      xcargs: "CODE_SIGN_STYLE=Manual DEVELOPMENT_TEAM=#{ENV['APPLE_TEAM_ID']} CODE_SIGN_IDENTITY='Apple Distribution' PROVISIONING_PROFILE_SPECIFIER='match AppStore io.asterixorobelix.afrikaburn.Afrikaburn'"
    )

    UI.success("iOS app built successfully!")
  end

  desc "Build iOS app for development/testing"
  lane :build_dev do
    build_framework
    certificates_dev

    ios_ws = File.join(mobile_root, "iosApp", "iosApp.xcworkspace")
    ios_proj = File.join(mobile_root, "iosApp", "iosApp.xcodeproj")
    container = File.directory?(ios_ws) ? { workspace: ios_ws } : { project: ios_proj }

    build_app(
      **container,
      scheme: "iosApp",
      export_method: "development",
      output_directory: "./build",
      output_name: "AfrikaBurnCompanion-dev.ipa"
    )
  end

  desc "Deploy to TestFlight"
  lane :beta do
    build

    api_key = asc_api_key
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      notify_external_testers: false,
      changelog: generate_changelog
    )

    UI.success("Successfully deployed to TestFlight!")
  end

  desc "Upload App Store screenshots (metadata only)"
  lane :upload_screenshots do
    screenshots_dir = "screenshots"
    unless Dir.exist?(screenshots_dir)
      UI.user_error!("Missing iOS screenshots directory at #{screenshots_dir}.")
    end

    if Dir.glob("#{screenshots_dir}/**/*.png").empty?
      UI.important("No iOS screenshots found. Skipping upload.")
      next
    end

    api_key = asc_api_key
    deliver(
      api_key: api_key,
      skip_binary_upload: true,
      skip_metadata: true,
      skip_screenshots: false,
      overwrite_screenshots: true,
      run_precheck_before_submit: false
    )

    UI.success("Successfully uploaded App Store screenshots!")
  end

  desc "Deploy to TestFlight with external testers"
  lane :beta_external do
    build

    api_key = asc_api_key
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: false,
      distribute_external: true,
      notify_external_testers: true,
      groups: ["Beta Testers"],
      changelog: generate_changelog
    )

    UI.success("Successfully deployed to TestFlight for external testers!")
  end

  desc "Submit to App Store for review"
  lane :release do
    build

    api_key = asc_api_key
    upload_to_app_store(
      api_key: api_key,
      submit_for_review: false,
      automatic_release: false,
      force: true,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false
      }
    )

    UI.success("Successfully uploaded to App Store Connect!")
    UI.important("Remember to submit for review manually in App Store Connect")
  end

  desc "Submit to App Store and request review"
  lane :release_submit do
    precheck_app
    build

    api_key = asc_api_key
    upload_to_app_store(
      api_key: api_key,
      submit_for_review: true,
      automatic_release: true,
      force: true,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false
      }
    )

    UI.success("Successfully submitted to App Store for review!")
  end

end

# ============================================================================
# SHARED / UTILITY LANES
# ============================================================================

desc "Generate changelog from recent git commits"
private_lane :generate_changelog do
  changelog = changelog_from_git_commits(
    commits_count: 10,
    pretty: "- %s",
    date_format: "short",
    merge_commit_filtering: "exclude_merges"
  )

  # Limit length for App Store
  if changelog.length > 4000
    changelog = changelog[0..3990] + "..."
  end

  changelog
end

desc "Print changelog (useful for release notes)"
lane :changelog do
  puts generate_changelog
end

desc "Run all tests (Android)"
lane :test_all do
  android_test
end

desc "Clean build artifacts"
lane :clean do
  gradle(
    project_dir: "..",
    task: "clean"
  )

  # Clean fastlane build directory
  sh("rm -rf ./build")

  UI.success("Build artifacts cleaned!")
end

desc "Check if all environment variables are configured"
lane :check_env do
  required_vars = [
    "KEYSTORE_PATH",
    "KEYSTORE_PASSWORD",
    "KEY_ALIAS",
    "KEY_PASSWORD"
  ]

  ios_vars = [
    "MATCH_PASSWORD",
    "MATCH_GIT_URL"
  ]

  UI.header("Android Environment Check")
  required_vars.each do |var|
    if ENV[var].nil? || ENV[var].empty?
      UI.error("Missing: #{var}")
    else
      UI.success("Found: #{var}")
    end
  end

  UI.header("iOS Environment Check")
  ios_vars.each do |var|
    if ENV[var].nil? || ENV[var].empty?
      UI.error("Missing: #{var}")
    else
      UI.success("Found: #{var}")
    end
  end
end

# Error handling
error do |lane, exception|
  UI.error("Lane #{lane} failed with error: #{exception.message}")
end
