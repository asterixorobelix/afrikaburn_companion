# Fastfile for AfrikaBurn Companion
# Compose Multiplatform app deployment automation
#
# Documentation: https://docs.fastlane.tools

default_platform(:android)

# App Store Connect API Key for CI authentication (avoids password/2FA issues)
# Requires secrets: ASC_KEY_ID, ASC_ISSUER_ID, ASC_KEY_CONTENT (base64 .p8)
def asc_api_key
  if ENV['ASC_KEY_ID'] && ENV['ASC_ISSUER_ID'] && ENV['ASC_KEY_CONTENT']
    app_store_connect_api_key(
      key_id: ENV['ASC_KEY_ID'],
      issuer_id: ENV['ASC_ISSUER_ID'],
      key_content: ENV['ASC_KEY_CONTENT'],
      is_key_content_base64: true
    )
  else
    nil
  end
end

# ============================================================================
# ANDROID LANES
# ============================================================================
platform :android do

  desc "Run Android unit tests"
  lane :test do
    gradle(
      project_dir: ".",
      task: ":composeApp:testDebugUnitTest"
    )
  end

  desc "Run detekt code analysis"
  lane :lint do
    gradle(
      project_dir: ".",
      task: "detekt"
    )
  end

  desc "Build debug APK"
  lane :build_debug do
    gradle(
      project_dir: ".",
      task: ":composeApp:assembleDebug"
    )

    APK_LOCATION = lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH]
    UI.success("Debug APK built: #{APK_LOCATION}")
  end

  desc "Build release AAB for Play Store"
  lane :build_release do
    # Ensure we have signing configuration
    ensure_env_vars(
      env_vars: ["KEYSTORE_PATH", "KEYSTORE_PASSWORD", "KEY_ALIAS", "KEY_PASSWORD"]
    )

    gradle(
      project_dir: ".",
      task: ":composeApp:bundleRelease",
      properties: {
        "android.injected.signing.store.file" => ENV["KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      }
    )

    AAB_LOCATION = "composeApp/build/outputs/bundle/release/composeApp-release.aab"
    UI.success("Release AAB built: #{AAB_LOCATION}")
  end

  desc "Build release APK (for direct distribution)"
  lane :build_release_apk do
    ensure_env_vars(
      env_vars: ["KEYSTORE_PATH", "KEYSTORE_PASSWORD", "KEY_ALIAS", "KEY_PASSWORD"]
    )

    gradle(
      project_dir: ".",
      task: ":composeApp:assembleRelease",
      properties: {
        "android.injected.signing.store.file" => ENV["KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      }
    )
  end

  desc "Increment version code"
  lane :bump_version do
    # Read current version from build.gradle.kts
    build_file = "composeApp/build.gradle.kts"
    content = File.read(build_file)

    # Extract and increment version code
    current_version_code = content.match(/versionCode = (\d+)/)[1].to_i
    new_version_code = current_version_code + 1

    # Update version code
    new_content = content.gsub(/versionCode = \d+/, "versionCode = #{new_version_code}")
    File.write(build_file, new_content)

    UI.success("Version code bumped: #{current_version_code} -> #{new_version_code}")
    new_version_code
  end

  desc "Deploy to Play Store Internal Testing track"
  lane :internal do
    test
    lint
    bump_version
    build_release

    upload_to_play_store(
      track: "internal",
      aab: "composeApp/build/outputs/bundle/release/composeApp-release.aab",
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      release_status: "completed"
    )

    UI.success("Successfully deployed to Internal Testing!")
  end

  desc "Capture Android screenshots for Play Store"
  lane :screenshots do
    screengrab(
      clear_previous_screenshots: true,
      locales: ["en-US"]
    )
  end

  desc "Upload Play Store internal track build + screenshots (CI)"
  lane :upload_internal do |options|
    ensure_env_vars(
      env_vars: ["GOOGLE_PLAY_SERVICE_ACCOUNT_JSON"]
    )

    aab_path = options[:aab] || "composeApp/build/outputs/bundle/release/composeApp-release.aab"
    metadata_path = options[:metadata_path] || "metadata/android"

    resolved_aab = Dir.glob(aab_path).first || File.expand_path(aab_path, Dir.pwd)
    unless File.exist?(resolved_aab)
      UI.user_error!("Missing AAB at #{aab_path}. Provide via aab: option.")
    end

    resolved_aab = File.expand_path(resolved_aab, Dir.pwd)

    unless Dir.exist?(metadata_path)
      UI.user_error!("Missing Android metadata directory at #{metadata_path}.")
    end

    upload_to_play_store(
      track: "internal",
      aab: resolved_aab,
      json_key_data: ENV["GOOGLE_PLAY_SERVICE_ACCOUNT_JSON"],
      metadata_path: metadata_path,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: false,
      release_status: "completed"
    )

    UI.success("Successfully uploaded screenshots and deployed to Internal Testing!")
  end

  desc "CI lane: capture screenshots and deploy to Internal Testing"
  lane :ci_internal do |options|
    screenshots
    upload_internal(options)
  end

  desc "Deploy to Play Store Beta (Open Testing)"
  lane :beta do
    test
    lint
    bump_version
    build_release

    upload_to_play_store(
      track: "beta",
      aab: "composeApp/build/outputs/bundle/release/composeApp-release.aab",
      skip_upload_metadata: false,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Successfully deployed to Beta!")
  end

  desc "Deploy to Play Store Production (with staged rollout)"
  lane :release do |options|
    rollout_percentage = options[:rollout] || 0.1

    test
    lint
    bump_version
    build_release

    upload_to_play_store(
      track: "production",
      aab: "composeApp/build/outputs/bundle/release/composeApp-release.aab",
      rollout: rollout_percentage.to_s
    )

    UI.success("Successfully deployed to Production with #{(rollout_percentage * 100).to_i}% rollout!")
  end

  desc "Promote Internal to Beta"
  lane :promote_to_beta do
    upload_to_play_store(
      track: "internal",
      track_promote_to: "beta",
      skip_upload_aab: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Promoted Internal to Beta!")
  end

  desc "Promote Beta to Production"
  lane :promote_to_production do |options|
    rollout_percentage = options[:rollout] || 0.1

    upload_to_play_store(
      track: "beta",
      track_promote_to: "production",
      rollout: rollout_percentage.to_s,
      skip_upload_aab: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Promoted Beta to Production with #{(rollout_percentage * 100).to_i}% rollout!")
  end

end

# ============================================================================
# iOS LANES
# ============================================================================
platform :ios do

  desc "Sync code signing certificates and provisioning profiles"
  lane :certificates do
    # Create a temporary keychain on CI so codesign doesn't hang
    # waiting for a keychain password prompt during framework embedding
    setup_ci if is_ci

    match(
      type: "appstore",
      readonly: is_ci,
      app_identifier: "io.asterixorobelix.afrikaburn.Afrikaburn"
    )
  end

  desc "Sync development certificates"
  lane :certificates_dev do
    setup_ci if is_ci

    match(
      type: "development",
      readonly: is_ci,
      app_identifier: "io.asterixorobelix.afrikaburn.Afrikaburn"
    )
  end

  desc "Run precheck to catch common App Store rejection issues"
  lane :precheck_app do
    precheck(
      app_identifier: "io.asterixorobelix.afrikaburn.Afrikaburn",
      unreachable_urls: :error,
      other_platforms: :error
    )
  end

  desc "Capture screenshots on iPhone and iPad simulators"
  lane :screenshots do
    helper_paths = [
      "iosApp/iosAppUITests/SnapshotHelper.swift"
    ]

    unless helper_paths.any? { |path| File.exist?(path) }
      UI.important("Snapshot helper missing. Skipping iOS screenshots.")
      next
    end

    capture_screenshots(
      workspace: "iosApp/iosApp.xcworkspace",
      scheme: "iosApp",
      devices: [
        "iPhone 16 Pro Max",
        "iPad Pro 13-inch (M4)"
      ]
    )
    frame_screenshots
  end

  desc "Run tests on iPhone and iPad simulators to catch launch crashes"
  lane :test do
    run_tests(
      workspace: "iosApp/iosApp.xcworkspace",
      scheme: "iosApp",
      devices: [
        "iPhone 16 Pro Max",
        "iPad Pro 11-inch (M4)"
      ],
      result_bundle: true
    )
  end

  desc "Build Kotlin Multiplatform framework (all targets)"
  lane :build_framework do
    gradle(
      project_dir: ".",
      task: ":composeApp:assembleReleaseXCFramework"
    )

    UI.success("XCFramework built successfully!")
  end

  desc "Build Kotlin framework for device only (arm64, faster for CD)"
  lane :build_framework_device do
    gradle(
      project_dir: ".",
      task: ":composeApp:assembleReleaseFrameworkDevice"
    )

    UI.success("Device framework built successfully!")
  end

  desc "Build iOS app for App Store"
  lane :build do
    # On CI, framework is pre-built by the workflow's Gradle step
    unless is_ci
      build_framework
    end

    # Sync certificates
    certificates

    # Build the iOS app (uses CocoaPods workspace for native dependency linking)
    # Note: PROVISIONING_PROFILE_SPECIFIER in xcargs is safe because Podfile post_install
    # disables code signing on Pods targets (CODE_SIGNING_ALLOWED=NO).
    # PRODUCT_BUNDLE_IDENTIFIER and PRODUCT_NAME are set in the iosApp target's build
    # settings (project.pbxproj) rather than xcargs to avoid leaking to Pods targets
    # (which would rename Pods_iosApp.framework and break linking).
    build_app(
      workspace: "iosApp/iosApp.xcworkspace",
      scheme: "iosApp",
      export_method: "app-store",
      output_directory: "./build",
      output_name: "AfrikaBurnCompanion.ipa",
      clean: true,
      xcargs: "CODE_SIGN_STYLE=Manual DEVELOPMENT_TEAM=#{ENV['APPLE_TEAM_ID']} CODE_SIGN_IDENTITY='Apple Distribution' PROVISIONING_PROFILE_SPECIFIER='match AppStore io.asterixorobelix.afrikaburn.Afrikaburn'"
    )

    UI.success("iOS app built successfully!")
  end

  desc "Build iOS app for development/testing"
  lane :build_dev do
    build_framework
    certificates_dev

    build_app(
      workspace: "iosApp/iosApp.xcworkspace",
      scheme: "iosApp",
      export_method: "development",
      output_directory: "./build",
      output_name: "AfrikaBurnCompanion-dev.ipa"
    )
  end

  desc "Deploy to TestFlight"
  lane :beta do
    build

    api_key = asc_api_key
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      notify_external_testers: false,
      changelog: generate_changelog
    )

    UI.success("Successfully deployed to TestFlight!")
  end

  desc "Upload App Store screenshots (metadata only)"
  lane :upload_screenshots do
    screenshots_dir = "screenshots"
    unless Dir.exist?(screenshots_dir)
      UI.user_error!("Missing iOS screenshots directory at #{screenshots_dir}.")
    end

    if Dir.glob("#{screenshots_dir}/**/*.png").empty?
      UI.important("No iOS screenshots found. Skipping upload.")
      next
    end

    api_key = asc_api_key
    deliver(
      api_key: api_key,
      skip_binary_upload: true,
      skip_metadata: true,
      skip_screenshots: false,
      overwrite_screenshots: true,
      run_precheck_before_submit: false
    )

    UI.success("Successfully uploaded App Store screenshots!")
  end

  desc "Deploy to TestFlight with external testers"
  lane :beta_external do
    build

    api_key = asc_api_key
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: false,
      distribute_external: true,
      notify_external_testers: true,
      groups: ["Beta Testers"],
      changelog: generate_changelog
    )

    UI.success("Successfully deployed to TestFlight for external testers!")
  end

  desc "Submit to App Store for review"
  lane :release do
    build

    api_key = asc_api_key
    upload_to_app_store(
      api_key: api_key,
      submit_for_review: false,
      automatic_release: false,
      force: true,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false
      }
    )

    UI.success("Successfully uploaded to App Store Connect!")
    UI.important("Remember to submit for review manually in App Store Connect")
  end

  desc "Submit to App Store and request review"
  lane :release_submit do
    precheck_app
    build

    api_key = asc_api_key
    upload_to_app_store(
      api_key: api_key,
      submit_for_review: true,
      automatic_release: true,
      force: true,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false
      }
    )

    UI.success("Successfully submitted to App Store for review!")
  end

end

# ============================================================================
# SHARED / UTILITY LANES
# ============================================================================

desc "Generate changelog from recent git commits"
private_lane :generate_changelog do
  changelog = changelog_from_git_commits(
    commits_count: 10,
    pretty: "- %s",
    date_format: "short",
    merge_commit_filtering: "exclude_merges"
  )

  # Limit length for App Store
  if changelog.length > 4000
    changelog = changelog[0..3990] + "..."
  end

  changelog
end

desc "Print changelog (useful for release notes)"
lane :changelog do
  puts generate_changelog
end

desc "Run all tests (Android)"
lane :test_all do
  android_test
end

desc "Clean build artifacts"
lane :clean do
  gradle(
    project_dir: "..",
    task: "clean"
  )

  # Clean fastlane build directory
  sh("rm -rf ./build")

  UI.success("Build artifacts cleaned!")
end

desc "Check if all environment variables are configured"
lane :check_env do
  required_vars = [
    "KEYSTORE_PATH",
    "KEYSTORE_PASSWORD",
    "KEY_ALIAS",
    "KEY_PASSWORD"
  ]

  ios_vars = [
    "MATCH_PASSWORD",
    "MATCH_GIT_URL"
  ]

  UI.header("Android Environment Check")
  required_vars.each do |var|
    if ENV[var].nil? || ENV[var].empty?
      UI.error("Missing: #{var}")
    else
      UI.success("Found: #{var}")
    end
  end

  UI.header("iOS Environment Check")
  ios_vars.each do |var|
    if ENV[var].nil? || ENV[var].empty?
      UI.error("Missing: #{var}")
    else
      UI.success("Found: #{var}")
    end
  end
end

# Error handling
error do |lane, exception|
  UI.error("Lane #{lane} failed with error: #{exception.message}")
end
