---
phase: 04-user-camp-pin
plan: 01
type: execute
wave: 1
depends_on: ["03-01"]
files_modified:
  - mobile/gradle/libs.versions.toml
  - mobile/composeApp/build.gradle.kts
  - mobile/composeApp/src/commonMain/sqldelight/io/asterixorobelix/afrikaburn/UserCampPin.sq
  - mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.kt
  - mobile/composeApp/src/androidMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.android.kt
  - mobile/composeApp/src/iosMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.ios.kt
  - mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/domain/repository/UserCampPinRepository.kt
  - mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/data/repository/UserCampPinRepositoryImpl.kt
  - mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/di/DatabaseModule.kt
autonomous: true

must_haves:
  truths:
    - "SQLDelight database is configured and generates Kotlin code"
    - "UserCampPin table schema exists with id, latitude, longitude, name, createdAt columns"
    - "DatabaseDriverFactory provides platform-specific drivers (Android/iOS)"
    - "UserCampPinRepository can save, retrieve, update, and delete pins"
    - "Repository is registered in Koin DI and injectable"
  artifacts:
    - path: "mobile/composeApp/src/commonMain/sqldelight/io/asterixorobelix/afrikaburn/UserCampPin.sq"
      provides: "SQLDelight schema for user camp pin"
      contains: "CREATE TABLE UserCampPin"
    - path: "mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.kt"
      provides: "Expect declaration for platform database driver"
      contains: "expect class DatabaseDriverFactory"
    - path: "mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/domain/repository/UserCampPinRepository.kt"
      provides: "Repository interface with CRUD operations"
      exports: ["getUserCampPin", "saveUserCampPin", "deleteUserCampPin"]
    - path: "mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/data/repository/UserCampPinRepositoryImpl.kt"
      provides: "Repository implementation using SQLDelight"
      contains: "class UserCampPinRepositoryImpl"
  key_links:
    - from: "UserCampPinRepositoryImpl.kt"
      to: "AfrikaBurnDatabase"
      via: "SQLDelight generated queries"
      pattern: "database\\.userCampPinQueries"
    - from: "DatabaseModule.kt"
      to: "UserCampPinRepository"
      via: "Koin single/factory"
      pattern: "single.*UserCampPinRepository"
---

<objective>
Set up SQLDelight database infrastructure and create UserCampPinRepository for persisting user's camp pin location.

Purpose: Establish the data layer foundation required for PIN-02 (persistence across app restarts). SQLDelight provides type-safe, multiplatform local database that matches the project's existing architecture.
Output: Working SQLDelight configuration, platform-specific drivers, and repository with full CRUD operations for user camp pins.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-user-location/03-01-SUMMARY.md

# Key source files:
@mobile/gradle/libs.versions.toml
@mobile/composeApp/build.gradle.kts
@mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/di/AppModule.kt
@mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/platform/LocationService.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SQLDelight dependencies to version catalog</name>
  <files>mobile/gradle/libs.versions.toml</files>
  <action>
Add SQLDelight dependencies to libs.versions.toml:

In [versions] section, add:
```toml
sqldelight = "2.0.2"
```

In [libraries] section, add:
```toml
sqldelight-runtime = { module = "app.cash.sqldelight:runtime", version.ref = "sqldelight" }
sqldelight-coroutines = { module = "app.cash.sqldelight:coroutines-extensions", version.ref = "sqldelight" }
sqldelight-android-driver = { module = "app.cash.sqldelight:android-driver", version.ref = "sqldelight" }
sqldelight-native-driver = { module = "app.cash.sqldelight:native-driver", version.ref = "sqldelight" }
```

In [plugins] section, add:
```toml
sqldelight = { id = "app.cash.sqldelight", version.ref = "sqldelight" }
```

Use SQLDelight 2.0.2 for Kotlin 2.x compatibility.
  </action>
  <verify>File has valid TOML syntax: `cat mobile/gradle/libs.versions.toml | head -50`</verify>
  <done>SQLDelight version, libraries, and plugin declared in version catalog</done>
</task>

<task type="auto">
  <name>Task 2: Configure SQLDelight plugin in build.gradle.kts</name>
  <files>mobile/composeApp/build.gradle.kts</files>
  <action>
Update build.gradle.kts to configure SQLDelight:

1. Add the plugin alias to the plugins block:
```kotlin
alias(libs.plugins.sqldelight)
```

2. Add SQLDelight configuration at the end of the file (before or after compose block):
```kotlin
sqldelight {
    databases {
        create("AfrikaBurnDatabase") {
            packageName.set("io.asterixorobelix.afrikaburn.data.database")
        }
    }
}
```

3. Add dependencies in the appropriate source sets:

In commonMain.dependencies:
```kotlin
implementation(libs.sqldelight.runtime)
implementation(libs.sqldelight.coroutines)
```

In androidMain.dependencies:
```kotlin
implementation(libs.sqldelight.android.driver)
```

In iosMain.dependencies:
```kotlin
implementation(libs.sqldelight.native.driver)
```

The database name "AfrikaBurnDatabase" will generate `AfrikaBurnDatabase.kt` class.
  </action>
  <verify>Gradle sync succeeds: `cd /Users/nathanstasin/Documents/afrikaburn_companion/mobile && ./gradlew :composeApp:dependencies --configuration commonMainImplementation 2>&1 | head -30`</verify>
  <done>SQLDelight plugin configured and dependencies added</done>
</task>

<task type="auto">
  <name>Task 3: Create UserCampPin SQLDelight schema</name>
  <files>mobile/composeApp/src/commonMain/sqldelight/io/asterixorobelix/afrikaburn/UserCampPin.sq</files>
  <action>
Create the SQLDelight schema file at:
`mobile/composeApp/src/commonMain/sqldelight/io/asterixorobelix/afrikaburn/UserCampPin.sq`

Note: Create the full directory path `sqldelight/io/asterixorobelix/afrikaburn/` under commonMain.

Content:
```sql
-- User's personal camp pin location
-- Only one pin is allowed per user (enforced by app logic, not schema)

CREATE TABLE UserCampPin (
    id INTEGER PRIMARY KEY NOT NULL,
    latitude REAL NOT NULL,
    longitude REAL NOT NULL,
    name TEXT NOT NULL DEFAULT 'My Camp',
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL
);

-- Get the user's camp pin (should only be one)
getUserCampPin:
SELECT * FROM UserCampPin LIMIT 1;

-- Insert or replace the user's camp pin
-- Uses id = 1 to ensure only one pin exists
saveUserCampPin:
INSERT OR REPLACE INTO UserCampPin (id, latitude, longitude, name, createdAt, updatedAt)
VALUES (1, ?, ?, ?, ?, ?);

-- Update just the location (for move operation)
updateLocation:
UPDATE UserCampPin SET latitude = ?, longitude = ?, updatedAt = ? WHERE id = 1;

-- Update the name
updateName:
UPDATE UserCampPin SET name = ?, updatedAt = ? WHERE id = 1;

-- Delete the user's camp pin
deleteUserCampPin:
DELETE FROM UserCampPin WHERE id = 1;

-- Check if pin exists
hasCampPin:
SELECT COUNT(*) > 0 FROM UserCampPin WHERE id = 1;
```

The schema uses id = 1 for the single pin pattern. Timestamps use INTEGER for Unix epoch milliseconds.
  </action>
  <verify>File exists and has valid SQL: `cat mobile/composeApp/src/commonMain/sqldelight/io/asterixorobelix/afrikaburn/UserCampPin.sq`</verify>
  <done>UserCampPin.sq schema created with CRUD queries</done>
</task>

<task type="auto">
  <name>Task 4: Create DatabaseDriverFactory expect declaration</name>
  <files>mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.kt</files>
  <action>
Create the expect class for platform-specific database drivers:

Path: `mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.kt`

```kotlin
package io.asterixorobelix.afrikaburn.data.database

import app.cash.sqldelight.db.SqlDriver

expect class DatabaseDriverFactory {
    fun createDriver(): SqlDriver
}
```

This follows the same expect/actual pattern used by LocationService.
  </action>
  <verify>File compiles: `cd /Users/nathanstasin/Documents/afrikaburn_companion/mobile && ./gradlew :composeApp:compileCommonMainKotlinMetadata 2>&1 | tail -10`</verify>
  <done>DatabaseDriverFactory expect declaration created</done>
</task>

<task type="auto">
  <name>Task 5: Create Android DatabaseDriverFactory implementation</name>
  <files>mobile/composeApp/src/androidMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.android.kt</files>
  <action>
Create Android actual implementation:

Path: `mobile/composeApp/src/androidMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.android.kt`

```kotlin
package io.asterixorobelix.afrikaburn.data.database

import android.content.Context
import app.cash.sqldelight.db.SqlDriver
import app.cash.sqldelight.driver.android.AndroidSqliteDriver

actual class DatabaseDriverFactory(private val context: Context) {
    actual fun createDriver(): SqlDriver {
        return AndroidSqliteDriver(
            schema = AfrikaBurnDatabase.Schema,
            context = context,
            name = "afrikaburn.db"
        )
    }
}
```

Note: AfrikaBurnDatabase will be generated by SQLDelight after build. The import will be:
`import io.asterixorobelix.afrikaburn.data.database.AfrikaBurnDatabase`
  </action>
  <verify>File exists with correct package: `head -10 mobile/composeApp/src/androidMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.android.kt`</verify>
  <done>Android DatabaseDriverFactory implementation created</done>
</task>

<task type="auto">
  <name>Task 6: Create iOS DatabaseDriverFactory implementation</name>
  <files>mobile/composeApp/src/iosMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.ios.kt</files>
  <action>
Create iOS actual implementation:

Path: `mobile/composeApp/src/iosMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.ios.kt`

```kotlin
package io.asterixorobelix.afrikaburn.data.database

import app.cash.sqldelight.db.SqlDriver
import app.cash.sqldelight.driver.native.NativeSqliteDriver

actual class DatabaseDriverFactory {
    actual fun createDriver(): SqlDriver {
        return NativeSqliteDriver(
            schema = AfrikaBurnDatabase.Schema,
            name = "afrikaburn.db"
        )
    }
}
```

Note: iOS driver doesn't need Context. AfrikaBurnDatabase will be generated by SQLDelight.
  </action>
  <verify>File exists with correct package: `head -10 mobile/composeApp/src/iosMain/kotlin/io/asterixorobelix/afrikaburn/data/database/DatabaseDriverFactory.ios.kt`</verify>
  <done>iOS DatabaseDriverFactory implementation created</done>
</task>

<task type="auto">
  <name>Task 7: Generate SQLDelight code and verify</name>
  <files>N/A</files>
  <action>
Run Gradle to generate SQLDelight code:

```bash
cd /Users/nathanstasin/Documents/afrikaburn_companion/mobile && ./gradlew :composeApp:generateCommonMainAfrikaBurnDatabaseInterface
```

This will generate:
- `AfrikaBurnDatabase.kt` - The database class
- `UserCampPin.kt` - The data class for table rows
- `UserCampPinQueries.kt` - Type-safe query methods

If the task name doesn't exist, try:
```bash
./gradlew :composeApp:generateSqlDelightInterface
```

Or just build which includes generation:
```bash
./gradlew :composeApp:compileCommonMainKotlinMetadata
```

After generation, verify the generated code exists in the build directory.
  </action>
  <verify>SQLDelight generates code: `ls -la mobile/composeApp/build/generated/sqldelight/code/AfrikaBurnDatabase/commonMain/io/asterixorobelix/afrikaburn/data/database/ 2>/dev/null || echo "Run gradle build to generate"</verify>
  <done>SQLDelight code generated successfully</done>
</task>

<task type="auto">
  <name>Task 8: Create UserCampPinRepository domain interface</name>
  <files>mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/domain/repository/UserCampPinRepository.kt</files>
  <action>
Create the repository interface in the domain layer:

Path: `mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/domain/repository/UserCampPinRepository.kt`

```kotlin
package io.asterixorobelix.afrikaburn.domain.repository

import kotlinx.coroutines.flow.Flow

/**
 * Repository for managing the user's personal camp pin on the map.
 * Only one camp pin is allowed per user.
 */
interface UserCampPinRepository {
    /**
     * Observe the user's camp pin. Emits null if no pin exists.
     */
    fun observeCampPin(): Flow<UserCampPinData?>

    /**
     * Get the current camp pin, or null if none exists.
     */
    suspend fun getCampPin(): UserCampPinData?

    /**
     * Save or update the user's camp pin location.
     * @param latitude GPS latitude
     * @param longitude GPS longitude
     * @param name Optional name for the pin (defaults to "My Camp")
     */
    suspend fun saveCampPin(latitude: Double, longitude: Double, name: String = "My Camp")

    /**
     * Update just the pin's location (for move operations).
     */
    suspend fun updateLocation(latitude: Double, longitude: Double)

    /**
     * Update the pin's name.
     */
    suspend fun updateName(name: String)

    /**
     * Delete the user's camp pin.
     */
    suspend fun deleteCampPin()

    /**
     * Check if a camp pin exists.
     */
    suspend fun hasCampPin(): Boolean
}

/**
 * Data class representing the user's camp pin.
 */
data class UserCampPinData(
    val id: Long,
    val latitude: Double,
    val longitude: Double,
    val name: String,
    val createdAt: Long,
    val updatedAt: Long
)
```

The interface follows the repository pattern established in the project. Using Flow for reactive observation matches the StateFlow pattern in ViewModels.
  </action>
  <verify>File compiles: `cd /Users/nathanstasin/Documents/afrikaburn_companion/mobile && ./gradlew :composeApp:compileCommonMainKotlinMetadata 2>&1 | tail -10`</verify>
  <done>UserCampPinRepository interface created with CRUD methods</done>
</task>

<task type="auto">
  <name>Task 9: Create UserCampPinRepositoryImpl data layer</name>
  <files>mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/data/repository/UserCampPinRepositoryImpl.kt</files>
  <action>
Create the repository implementation using SQLDelight:

Path: `mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/data/repository/UserCampPinRepositoryImpl.kt`

```kotlin
package io.asterixorobelix.afrikaburn.data.repository

import app.cash.sqldelight.coroutines.asFlow
import app.cash.sqldelight.coroutines.mapToOneOrNull
import io.asterixorobelix.afrikaburn.data.database.AfrikaBurnDatabase
import io.asterixorobelix.afrikaburn.domain.repository.UserCampPinData
import io.asterixorobelix.afrikaburn.domain.repository.UserCampPinRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.IO
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext

class UserCampPinRepositoryImpl(
    private val database: AfrikaBurnDatabase
) : UserCampPinRepository {

    private val queries get() = database.userCampPinQueries

    override fun observeCampPin(): Flow<UserCampPinData?> {
        return queries.getUserCampPin()
            .asFlow()
            .mapToOneOrNull(Dispatchers.IO)
            .map { pin ->
                pin?.let {
                    UserCampPinData(
                        id = it.id,
                        latitude = it.latitude,
                        longitude = it.longitude,
                        name = it.name,
                        createdAt = it.createdAt,
                        updatedAt = it.updatedAt
                    )
                }
            }
    }

    override suspend fun getCampPin(): UserCampPinData? = withContext(Dispatchers.IO) {
        queries.getUserCampPin().executeAsOneOrNull()?.let { pin ->
            UserCampPinData(
                id = pin.id,
                latitude = pin.latitude,
                longitude = pin.longitude,
                name = pin.name,
                createdAt = pin.createdAt,
                updatedAt = pin.updatedAt
            )
        }
    }

    override suspend fun saveCampPin(
        latitude: Double,
        longitude: Double,
        name: String
    ) = withContext(Dispatchers.IO) {
        val now = System.currentTimeMillis()
        queries.saveUserCampPin(
            latitude = latitude,
            longitude = longitude,
            name = name,
            createdAt = now,
            updatedAt = now
        )
    }

    override suspend fun updateLocation(
        latitude: Double,
        longitude: Double
    ) = withContext(Dispatchers.IO) {
        val now = System.currentTimeMillis()
        queries.updateLocation(
            latitude = latitude,
            longitude = longitude,
            updatedAt = now
        )
    }

    override suspend fun updateName(name: String) = withContext(Dispatchers.IO) {
        val now = System.currentTimeMillis()
        queries.updateName(name = name, updatedAt = now)
    }

    override suspend fun deleteCampPin() = withContext(Dispatchers.IO) {
        queries.deleteUserCampPin()
    }

    override suspend fun hasCampPin(): Boolean = withContext(Dispatchers.IO) {
        queries.hasCampPin().executeAsOne()
    }
}
```

Uses Dispatchers.IO for database operations. The mapping from SQLDelight generated type to domain type keeps the domain layer clean.
  </action>
  <verify>File compiles: `cd /Users/nathanstasin/Documents/afrikaburn_companion/mobile && ./gradlew :composeApp:compileCommonMainKotlinMetadata 2>&1 | tail -10`</verify>
  <done>UserCampPinRepositoryImpl created with SQLDelight integration</done>
</task>

<task type="auto">
  <name>Task 10: Create DatabaseModule for Koin DI</name>
  <files>mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/di/DatabaseModule.kt</files>
  <action>
Create the Koin module for database dependencies:

Path: `mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/di/DatabaseModule.kt`

```kotlin
package io.asterixorobelix.afrikaburn.di

import io.asterixorobelix.afrikaburn.data.database.AfrikaBurnDatabase
import io.asterixorobelix.afrikaburn.data.database.DatabaseDriverFactory
import io.asterixorobelix.afrikaburn.data.repository.UserCampPinRepositoryImpl
import io.asterixorobelix.afrikaburn.domain.repository.UserCampPinRepository
import org.koin.dsl.module

val databaseModule = module {
    // Database driver factory - platform specific
    // Android: get() provides Context
    // iOS: no dependencies
    single { DatabaseDriverFactory(get()) }

    // Database instance
    single {
        AfrikaBurnDatabase(get<DatabaseDriverFactory>().createDriver())
    }

    // Repository
    single<UserCampPinRepository> { UserCampPinRepositoryImpl(get()) }
}
```

Note: On Android, Koin's `get()` will provide the Context (registered elsewhere in app setup). On iOS, the empty constructor is used. If this causes issues, we may need platform-specific module variants.
  </action>
  <verify>File compiles: `cd /Users/nathanstasin/Documents/afrikaburn_companion/mobile && ./gradlew :composeApp:compileCommonMainKotlinMetadata 2>&1 | tail -10`</verify>
  <done>DatabaseModule created with Koin registrations</done>
</task>

<task type="auto">
  <name>Task 11: Register DatabaseModule in AppModule</name>
  <files>mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/di/AppModule.kt</files>
  <action>
Update AppModule.kt to include databaseModule in the modules list:

Find the existing appModule or modules list and add databaseModule:

```kotlin
// Add import at top
import io.asterixorobelix.afrikaburn.di.databaseModule

// In the modules list or wherever modules are combined:
val appModules = listOf(
    // existing modules...
    databaseModule,
    // other modules...
)
```

Or if using `modules()` function in startKoin:
```kotlin
startKoin {
    modules(
        // existing modules...
        databaseModule,
    )
}
```

The exact change depends on how AppModule.kt is structured. Add databaseModule to wherever modules are aggregated.
  </action>
  <verify>File compiles and module is included: `grep -n "databaseModule" mobile/composeApp/src/commonMain/kotlin/io/asterixorobelix/afrikaburn/di/AppModule.kt`</verify>
  <done>databaseModule registered in AppModule</done>
</task>

<task type="auto">
  <name>Task 12: Full build and verification</name>
  <files>N/A</files>
  <action>
Run full build to verify everything compiles together:

```bash
cd /Users/nathanstasin/Documents/afrikaburn_companion/mobile && ./gradlew :composeApp:assembleDebug
```

If build fails, common issues:
1. SQLDelight generated code not found - run `./gradlew :composeApp:generateSqlDelightInterface` first
2. Import issues - verify AfrikaBurnDatabase import path matches generated code location
3. Koin Context issue on iOS - may need platform-specific module setup

Also run detekt:
```bash
./gradlew detekt
```

Fix any issues before completing.
  </action>
  <verify>Build succeeds: `cd /Users/nathanstasin/Documents/afrikaburn_companion/mobile && ./gradlew :composeApp:assembleDebug 2>&1 | tail -20`</verify>
  <done>Full build passes with SQLDelight infrastructure</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew :composeApp:assembleDebug` succeeds
- [ ] `./gradlew detekt` passes (no new issues)
- [ ] SQLDelight generates AfrikaBurnDatabase class
- [ ] UserCampPin.sq schema has all required queries
- [ ] DatabaseDriverFactory has Android and iOS implementations
- [ ] UserCampPinRepository is injectable via Koin
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- SQLDelight 2.0.2 configured in Gradle
- UserCampPin table schema defined with id, latitude, longitude, name, timestamps
- Platform-specific database drivers created (Android SqliteDriver, iOS NativeDriver)
- UserCampPinRepository interface defines CRUD operations
- UserCampPinRepositoryImpl uses SQLDelight queries
- DatabaseModule registered in Koin DI
- Foundation ready for PIN-01/02/03/04 UI implementation in Plan 04-02
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-camp-pin/04-01-SUMMARY.md`
</output>
